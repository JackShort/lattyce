{"version":3,"sources":["../../src/plugins/PgBackwardRelationPlugin.js"],"names":["debug","OMIT","DEPRECATED","ONLY","PgBackwardRelationPlugin","builder","pgLegacyRelations","pgSimpleCollections","hasConnections","hasSimpleCollections","legacyRelationMode","only","deprecated","hook","fields","build","context","extend","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","getSafeAliasFromResolveInfo","getSafeAliasFromAlias","graphql","GraphQLNonNull","GraphQLList","inflection","pgQueryFromResolveData","queryFromResolveData","pgAddStartEndCursor","addStartEndCursor","pgOmit","omit","scope","isPgRowType","pgIntrospection","foreignTable","fieldWithHooks","Self","kind","foreignKeyConstraints","constraint","filter","con","type","foreignClassId","id","foreignAttributes","attribute","attr","classId","sort","a","b","num","reduce","memo","table","classById","tableTypeName","tableType","gqlTableType","foreignTableTypeName","gqlForeignTableType","Error","name","schema","namespace","attributes","keys","keyAttributeNums","map","foreignKeys","foreignKeyAttributeNums","every","_","some","key","singleKey","length","isUnique","find","c","isDeprecated","singleRelationFieldName","singleRelationByKeys","primaryKeyConstraint","primaryKeys","shouldAddSingleRelation","shouldAddManyRelation","getDataFromParsedResolveInfoFragment","addDataGenerator","parsedResolveInfoFragment","pgQuery","queryBuilder","select","resolveData","tableAlias","identifier","Symbol","foreignTableAlias","getTableAlias","query","asJson","addNullCase","withPagination","innerQueryBuilder","forEach","i","where","fragment","alias","description","args","resolve","data","_args","_context","resolveInfo","safeAlias","pgFieldIntrospection","makeFields","isConnection","manyRelationFieldName","manyRelationByKeys","manyRelationByKeysSimple","ConnectionType","TableType","withPaginationAsFields","asJsonAggregate","beforeLock","isOrderUnique","cursorPrefix","orderBy","setOrderIsUnique","connection","deprecationReason","undefined","isPgFieldConnection","isPgFieldSimpleCollection","isPgBackwardRelationField"],"mappings":"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","file":"PgBackwardRelationPlugin.js","sourcesContent":["// @flow\nimport debugFactory from \"debug\";\n\nimport type { Plugin } from \"graphile-build\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\n\nconst OMIT = 0;\nconst DEPRECATED = 1;\nconst ONLY = 2;\n\nexport default (function PgBackwardRelationPlugin(\n  builder,\n  { pgLegacyRelations, pgSimpleCollections }\n) {\n  const hasConnections = pgSimpleCollections !== \"only\";\n  const hasSimpleCollections =\n    pgSimpleCollections === \"only\" || pgSimpleCollections === \"both\";\n  const legacyRelationMode =\n    {\n      only: ONLY,\n      deprecated: DEPRECATED,\n    }[pgLegacyRelations] || OMIT;\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      getTypeByName,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      getSafeAliasFromResolveInfo,\n      getSafeAliasFromAlias,\n      graphql: { GraphQLNonNull, GraphQLList },\n      inflection,\n      pgQueryFromResolveData: queryFromResolveData,\n      pgAddStartEndCursor: addStartEndCursor,\n      pgOmit: omit,\n    } = build;\n    const {\n      scope: { isPgRowType, pgIntrospection: foreignTable },\n      fieldWithHooks,\n      Self,\n    } = context;\n    if (!isPgRowType || !foreignTable || foreignTable.kind !== \"class\") {\n      return fields;\n    }\n    // This is a relation in which WE are foreign\n    const foreignKeyConstraints = introspectionResultsByKind.constraint\n      .filter(con => con.type === \"f\")\n      .filter(con => con.foreignClassId === foreignTable.id);\n    const foreignAttributes = introspectionResultsByKind.attribute\n      .filter(attr => attr.classId === foreignTable.id)\n      .sort((a, b) => a.num - b.num);\n\n    return extend(\n      fields,\n      foreignKeyConstraints.reduce((memo, constraint) => {\n        if (omit(constraint, \"read\")) {\n          return memo;\n        }\n        const table = introspectionResultsByKind.classById[constraint.classId];\n        const tableTypeName = inflection.tableType(table);\n        const gqlTableType = pgGetGqlTypeByTypeIdAndModifier(\n          table.type.id,\n          null\n        );\n        if (!gqlTableType) {\n          debug(\n            `Could not determine type for table with id ${constraint.classId}`\n          );\n          return memo;\n        }\n        const foreignTable =\n          introspectionResultsByKind.classById[constraint.foreignClassId];\n        const foreignTableTypeName = inflection.tableType(foreignTable);\n        const gqlForeignTableType = pgGetGqlTypeByTypeIdAndModifier(\n          foreignTable.type.id,\n          null\n        );\n        if (!gqlForeignTableType) {\n          debug(\n            `Could not determine type for foreign table with id ${\n              constraint.foreignClassId\n            }`\n          );\n          return memo;\n        }\n        if (!table) {\n          throw new Error(\n            `Could not find the table that referenced us (constraint: ${\n              constraint.name\n            })`\n          );\n        }\n        const schema = table.namespace;\n\n        const attributes = introspectionResultsByKind.attribute.filter(\n          attr => attr.classId === table.id\n        );\n\n        const keys = constraint.keyAttributeNums.map(\n          num => attributes.filter(attr => attr.num === num)[0]\n        );\n        const foreignKeys = constraint.foreignKeyAttributeNums.map(\n          num => foreignAttributes.filter(attr => attr.num === num)[0]\n        );\n        if (!keys.every(_ => _) || !foreignKeys.every(_ => _)) {\n          throw new Error(\"Could not find key columns!\");\n        }\n        if (keys.some(key => omit(key, \"read\"))) {\n          return memo;\n        }\n        if (foreignKeys.some(key => omit(key, \"read\"))) {\n          return memo;\n        }\n        const singleKey = keys.length === 1 ? keys[0] : null;\n        const isUnique = !!(\n          singleKey &&\n          introspectionResultsByKind.constraint.find(\n            c =>\n              c.classId === singleKey.classId &&\n              c.keyAttributeNums.length === 1 &&\n              c.keyAttributeNums[0] === singleKey.num &&\n              (c.type === \"p\" || c.type === \"u\")\n          )\n        );\n\n        const isDeprecated = isUnique && legacyRelationMode === DEPRECATED;\n\n        const singleRelationFieldName = isUnique\n          ? inflection.singleRelationByKeys(\n              keys,\n              table,\n              foreignTable,\n              constraint\n            )\n          : null;\n\n        const primaryKeyConstraint = introspectionResultsByKind.constraint\n          .filter(con => con.classId === table.id)\n          .filter(con => con.type === \"p\")[0];\n        const primaryKeys =\n          primaryKeyConstraint &&\n          primaryKeyConstraint.keyAttributeNums.map(\n            num => attributes.filter(attr => attr.num === num)[0]\n          );\n\n        const shouldAddSingleRelation = isUnique && legacyRelationMode !== ONLY;\n\n        const shouldAddManyRelation =\n          !isUnique ||\n          legacyRelationMode === DEPRECATED ||\n          legacyRelationMode === ONLY;\n\n        if (shouldAddSingleRelation && !omit(table, \"read\")) {\n          memo[singleRelationFieldName] = fieldWithHooks(\n            singleRelationFieldName,\n            ({ getDataFromParsedResolveInfoFragment, addDataGenerator }) => {\n              addDataGenerator(parsedResolveInfoFragment => {\n                return {\n                  pgQuery: queryBuilder => {\n                    queryBuilder.select(() => {\n                      const resolveData = getDataFromParsedResolveInfoFragment(\n                        parsedResolveInfoFragment,\n                        gqlTableType\n                      );\n                      const tableAlias = sql.identifier(Symbol());\n                      const foreignTableAlias = queryBuilder.getTableAlias();\n                      const query = queryFromResolveData(\n                        sql.identifier(schema.name, table.name),\n                        tableAlias,\n                        resolveData,\n                        {\n                          asJson: true,\n                          addNullCase: true,\n                          withPagination: false,\n                        },\n                        innerQueryBuilder => {\n                          keys.forEach((key, i) => {\n                            innerQueryBuilder.where(\n                              sql.fragment`${tableAlias}.${sql.identifier(\n                                key.name\n                              )} = ${foreignTableAlias}.${sql.identifier(\n                                foreignKeys[i].name\n                              )}`\n                            );\n                          });\n                        }\n                      );\n                      return sql.fragment`(${query})`;\n                    }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n                  },\n                };\n              });\n              return {\n                description: `Reads a single \\`${tableTypeName}\\` that is related to this \\`${foreignTableTypeName}\\`.`,\n                type: gqlTableType,\n                args: {},\n                resolve: (data, _args, _context, resolveInfo) => {\n                  const safeAlias = getSafeAliasFromResolveInfo(resolveInfo);\n                  return data[safeAlias];\n                },\n              };\n            },\n            {\n              pgFieldIntrospection: table,\n            }\n          );\n        }\n        function makeFields(isConnection) {\n          if (isUnique && !isConnection) {\n            // Don't need this, use the singular instead\n            return;\n          }\n          if (shouldAddManyRelation && !omit(table, \"many\")) {\n            const manyRelationFieldName = isConnection\n              ? inflection.manyRelationByKeys(\n                  keys,\n                  table,\n                  foreignTable,\n                  constraint\n                )\n              : inflection.manyRelationByKeysSimple(\n                  keys,\n                  table,\n                  foreignTable,\n                  constraint\n                );\n\n            memo[manyRelationFieldName] = fieldWithHooks(\n              manyRelationFieldName,\n              ({ getDataFromParsedResolveInfoFragment, addDataGenerator }) => {\n                addDataGenerator(parsedResolveInfoFragment => {\n                  return {\n                    pgQuery: queryBuilder => {\n                      queryBuilder.select(() => {\n                        const resolveData = getDataFromParsedResolveInfoFragment(\n                          parsedResolveInfoFragment,\n                          isConnection ? ConnectionType : TableType\n                        );\n                        const tableAlias = sql.identifier(Symbol());\n                        const foreignTableAlias = queryBuilder.getTableAlias();\n                        const query = queryFromResolveData(\n                          sql.identifier(schema.name, table.name),\n                          tableAlias,\n                          resolveData,\n                          {\n                            withPagination: isConnection,\n                            withPaginationAsFields: false,\n                            asJsonAggregate: !isConnection,\n                          },\n                          innerQueryBuilder => {\n                            if (primaryKeys) {\n                              innerQueryBuilder.beforeLock(\"orderBy\", () => {\n                                // append order by primary key to the list of orders\n                                if (!innerQueryBuilder.isOrderUnique(false)) {\n                                  innerQueryBuilder.data.cursorPrefix = [\n                                    \"primary_key_asc\",\n                                  ];\n                                  primaryKeys.forEach(key => {\n                                    innerQueryBuilder.orderBy(\n                                      sql.fragment`${innerQueryBuilder.getTableAlias()}.${sql.identifier(\n                                        key.name\n                                      )}`,\n                                      true\n                                    );\n                                  });\n                                  innerQueryBuilder.setOrderIsUnique();\n                                }\n                              });\n                            }\n\n                            keys.forEach((key, i) => {\n                              innerQueryBuilder.where(\n                                sql.fragment`${tableAlias}.${sql.identifier(\n                                  key.name\n                                )} = ${foreignTableAlias}.${sql.identifier(\n                                  foreignKeys[i].name\n                                )}`\n                              );\n                            });\n                          }\n                        );\n                        return sql.fragment`(${query})`;\n                      }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n                    },\n                  };\n                });\n                const ConnectionType = getTypeByName(\n                  inflection.connection(gqlTableType.name)\n                );\n                const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                  table.type.id,\n                  null\n                );\n                return {\n                  description: `Reads and enables pagination through a set of \\`${tableTypeName}\\`.`,\n                  type: isConnection\n                    ? new GraphQLNonNull(ConnectionType)\n                    : new GraphQLNonNull(\n                        new GraphQLList(new GraphQLNonNull(TableType))\n                      ),\n                  args: {},\n                  resolve: (data, _args, _context, resolveInfo) => {\n                    const safeAlias = getSafeAliasFromResolveInfo(resolveInfo);\n                    if (isConnection) {\n                      return addStartEndCursor(data[safeAlias]);\n                    } else {\n                      return data[safeAlias];\n                    }\n                  },\n                  deprecationReason: isDeprecated\n                    ? // $FlowFixMe\n                      `Please use ${singleRelationFieldName} instead`\n                    : undefined,\n                };\n              },\n              {\n                isPgFieldConnection: isConnection,\n                isPgFieldSimpleCollection: !isConnection,\n                isPgBackwardRelationField: true,\n                pgFieldIntrospection: table,\n              }\n            );\n          }\n        }\n        if (hasConnections) {\n          makeFields(true);\n        }\n        if (hasSimpleCollections) {\n          makeFields(false);\n        }\n        return memo;\n      }, {}),\n      `Adding backward relations for ${Self.name}`\n    );\n  });\n}: Plugin);\n"]}