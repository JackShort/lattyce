{"version":3,"sources":["../../src/plugins/PgColumnsPlugin.js"],"names":["nullableIf","GraphQLNonNull","condition","Type","PgColumnsPlugin","builder","hook","fields","build","context","extend","pgGetGqlTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","pg2gql","graphql","GraphQLString","pgTweakFragmentForTypeAndModifier","pgColumnFilter","inflection","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","scope","isPgRowType","isPgCompoundType","pgIntrospection","table","fieldWithHooks","Self","kind","attribute","filter","attr","classId","id","reduce","memo","fieldName","column","Error","namespaceName","name","getDataFromParsedResolveInfoFragment","addDataGenerator","ReturnType","typeId","typeModifier","parsedResolveInfoFragment","pgQuery","queryBuilder","getSelectValueForFieldAndTypeAndModifier","sqlFullName","type","isPgArray","ident","identifier","Symbol","fragment","arrayItemType","resolveData","jsonBuildObject","onlyJsonField","addNullCase","select","getTableAlias","description","isNotNull","domainIsNotNull","resolve","data","_args","_context","_resolveInfo","pgFieldIntrospection","pgGetGqlInputTypeByTypeIdAndModifier","isPgPatch","isPgBaseInput","pgAddSubfield","hasDefault"],"mappings":"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","file":"PgColumnsPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nconst nullableIf = (GraphQLNonNull, condition, Type) =>\n  condition ? Type : new GraphQLNonNull(Type);\n\nexport default (function PgColumnsPlugin(builder) {\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      pg2gql,\n      graphql: { GraphQLString, GraphQLNonNull },\n      pgTweakFragmentForTypeAndModifier,\n      pgColumnFilter,\n      inflection,\n      pgQueryFromResolveData: queryFromResolveData,\n      pgOmit: omit,\n    } = build;\n    const {\n      scope: { isPgRowType, isPgCompoundType, pgIntrospection: table },\n      fieldWithHooks,\n      Self,\n    } = context;\n    if (\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\"\n    ) {\n      return fields;\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .filter(attr => pgColumnFilter(attr, build, context))\n        .filter(attr => !omit(attr, \"read\"))\n        .reduce((memo, attr) => {\n          /*\n            attr =\n              { kind: 'attribute',\n                classId: '6546809',\n                num: 21,\n                name: 'upstreamName',\n                description: null,\n                typeId: '6484393',\n                isNotNull: false,\n                hasDefault: false }\n            */\n          const fieldName = inflection.column(attr);\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on class '${\n                table.namespaceName\n              }.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo[fieldName] = fieldWithHooks(\n            fieldName,\n            ({ getDataFromParsedResolveInfoFragment, addDataGenerator }) => {\n              const ReturnType =\n                pgGetGqlTypeByTypeIdAndModifier(\n                  attr.typeId,\n                  attr.typeModifier\n                ) || GraphQLString;\n              addDataGenerator(parsedResolveInfoFragment => {\n                return {\n                  pgQuery: queryBuilder => {\n                    const getSelectValueForFieldAndTypeAndModifier = (\n                      sqlFullName,\n                      type,\n                      typeModifier\n                    ) => {\n                      if (type.isPgArray) {\n                        const ident = sql.identifier(Symbol());\n                        return sql.fragment`\n                          (\n                            case\n                            when ${sqlFullName} is null then null\n                            when coalesce(array_length(${sqlFullName}, 1), 0) = 0 then '[]'::json\n                            else\n                              (\n                                select json_agg(${getSelectValueForFieldAndTypeAndModifier(\n                                  ident,\n                                  type.arrayItemType,\n                                  typeModifier\n                                )})\n                                from unnest(${sqlFullName}) as ${ident}\n                              )\n                            end\n                          )\n                        `;\n                      } else {\n                        const resolveData = getDataFromParsedResolveInfoFragment(\n                          parsedResolveInfoFragment,\n                          ReturnType\n                        );\n                        if (type.type === \"c\") {\n                          const jsonBuildObject = queryFromResolveData(\n                            sql.identifier(Symbol()), // Ignore!\n                            sqlFullName,\n                            resolveData,\n                            { onlyJsonField: true, addNullCase: true }\n                          );\n                          return jsonBuildObject;\n                        } else {\n                          return pgTweakFragmentForTypeAndModifier(\n                            sqlFullName,\n                            type,\n                            typeModifier,\n                            resolveData\n                          );\n                        }\n                      }\n                    };\n                    queryBuilder.select(\n                      getSelectValueForFieldAndTypeAndModifier(\n                        sql.fragment`(${queryBuilder.getTableAlias()}.${sql.identifier(\n                          attr.name\n                        )})`, // The brackets are necessary to stop the parser getting confused, ref: https://www.postgresql.org/docs/9.6/static/rowtypes.html#ROWTYPES-ACCESSING\n                        attr.type,\n                        attr.typeModifier\n                      ),\n                      fieldName\n                    );\n                  },\n                };\n              });\n              return {\n                description: attr.description,\n                type: nullableIf(\n                  GraphQLNonNull,\n                  !attr.isNotNull && !attr.type.domainIsNotNull,\n                  ReturnType\n                ),\n                resolve: (data, _args, _context, _resolveInfo) => {\n                  return pg2gql(data[fieldName], attr.type);\n                },\n              };\n            },\n            { pgFieldIntrospection: attr }\n          );\n          return memo;\n        }, {}),\n      `Adding columns to '${Self.name}'`\n    );\n  });\n  builder.hook(\"GraphQLInputObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      pgGetGqlInputTypeByTypeIdAndModifier,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      graphql: { GraphQLString, GraphQLNonNull },\n      pgColumnFilter,\n      inflection,\n      pgOmit: omit,\n    } = build;\n    const {\n      scope: {\n        isPgRowType,\n        isPgCompoundType,\n        isPgPatch,\n        isPgBaseInput,\n        pgIntrospection: table,\n        pgAddSubfield,\n      },\n      fieldWithHooks,\n      Self,\n    } = context;\n    if (\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\"\n    ) {\n      return fields;\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .filter(attr => pgColumnFilter(attr, build, context))\n        .filter(\n          attr =>\n            !omit(\n              attr,\n              isPgBaseInput ? \"base\" : isPgPatch ? \"update\" : \"create\"\n            )\n        )\n        .reduce((memo, attr) => {\n          const fieldName = inflection.column(attr);\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on input class '${\n                table.namespaceName\n              }.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo[fieldName] = fieldWithHooks(\n            fieldName,\n            pgAddSubfield(\n              fieldName,\n              attr.name,\n              attr.type,\n              {\n                description: attr.description,\n                type: nullableIf(\n                  GraphQLNonNull,\n                  isPgBaseInput ||\n                    isPgPatch ||\n                    (!attr.isNotNull && !attr.type.domainIsNotNull) ||\n                    attr.hasDefault,\n                  pgGetGqlInputTypeByTypeIdAndModifier(\n                    attr.typeId,\n                    attr.typeModifier\n                  ) || GraphQLString\n                ),\n              },\n              attr.typeModifier\n            ),\n            { pgFieldIntrospection: attr }\n          );\n          return memo;\n        }, {}),\n      `Adding columns to input object '${Self.name}'`\n    );\n  });\n}: Plugin);\n"]}