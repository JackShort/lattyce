{"version":3,"sources":["../../src/plugins/PgComputedColumnsPlugin.js"],"names":["PgComputedColumnsPlugin","builder","pgSimpleCollections","hasConnections","hasSimpleCollections","hook","fields","build","context","scope","isPgRowType","isPgCompoundType","isInputType","pgIntrospection","table","fieldWithHooks","Self","kind","namespace","extend","pgIntrospectionResultsByKind","introspectionResultsByKind","inflection","pgOmit","omit","pgMakeProcField","makeProcField","swallowError","tableType","type","filter","namespaceId","classId","id","Error","procedure","proc","isStable","name","startsWith","argTypeIds","length","reduce","memo","argTypes","map","typeId","typeById","slice","some","class","isSelectable","pseudoColumnName","substr","makeField","forceList","fieldName","computedColumnList","computedColumn","computed","e","returnsSet"],"mappings":"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","file":"PgComputedColumnsPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nexport default (function PgComputedColumnsPlugin(\n  builder,\n  { pgSimpleCollections }\n) {\n  const hasConnections = pgSimpleCollections !== \"only\";\n  const hasSimpleCollections =\n    pgSimpleCollections === \"only\" || pgSimpleCollections === \"both\";\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      scope: {\n        isPgRowType,\n        isPgCompoundType,\n        isInputType,\n        pgIntrospection: table,\n      },\n      fieldWithHooks,\n      Self,\n    } = context;\n    if (\n      isInputType ||\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\" ||\n      !table.namespace\n    ) {\n      return fields;\n    }\n    const {\n      extend,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      inflection,\n      pgOmit: omit,\n      pgMakeProcField: makeProcField,\n      swallowError,\n    } = build;\n    const tableType = introspectionResultsByKind.type.filter(\n      type =>\n        type.type === \"c\" &&\n        type.namespaceId === table.namespaceId &&\n        type.classId === table.id\n    )[0];\n    if (!tableType) {\n      throw new Error(\"Could not determine the type for this table\");\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.procedure\n        .filter(proc => proc.isStable)\n        .filter(proc => proc.namespaceId === table.namespaceId)\n        .filter(proc => proc.name.startsWith(`${table.name}_`))\n        .filter(proc => proc.argTypeIds.length > 0)\n        .filter(proc => proc.argTypeIds[0] === tableType.id)\n        .filter(proc => !omit(proc, \"execute\"))\n        .reduce((memo, proc) => {\n          /*\n            proc =\n              { kind: 'procedure',\n                name: 'integration_webhook_secret',\n                description: null,\n                namespaceId: '6484381',\n                isStrict: false,\n                returnsSet: false,\n                isStable: true,\n                returnTypeId: '2950',\n                argTypeIds: [ '6484569' ],\n                argNames: [ 'integration' ],\n                argDefaultsNum: 0 }\n            */\n          const argTypes = proc.argTypeIds.map(\n            typeId => introspectionResultsByKind.typeById[typeId]\n          );\n          if (\n            argTypes\n              .slice(1)\n              .some(\n                type =>\n                  type.type === \"c\" && type.class && type.class.isSelectable\n              )\n          ) {\n            // Accepts two input tables? Skip.\n            return memo;\n          }\n\n          const pseudoColumnName = proc.name.substr(table.name.length + 1);\n          function makeField(forceList) {\n            const fieldName = forceList\n              ? inflection.computedColumnList(pseudoColumnName, proc, table)\n              : inflection.computedColumn(pseudoColumnName, proc, table);\n            try {\n              memo[fieldName] = makeProcField(fieldName, proc, build, {\n                fieldWithHooks,\n                computed: true,\n                forceList,\n              });\n            } catch (e) {\n              swallowError(e);\n            }\n          }\n          if (!proc.returnsSet || hasConnections) {\n            makeField(false);\n          }\n          if (proc.returnsSet && hasSimpleCollections) {\n            makeField(true);\n          }\n          return memo;\n        }, {}),\n      `Adding computed column to '${Self.name}'`\n    );\n  });\n}: Plugin);\n"]}