"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.preventEmptyResult = preventEmptyResult;

var _pgSql = require("pg-sql2");

var _pgSql2 = _interopRequireDefault(_pgSql);

var _package = require("../../package.json");

var _queryFromResolveData = require("../queryFromResolveData");

var _queryFromResolveData2 = _interopRequireDefault(_queryFromResolveData);

var _addStartEndCursor = require("./addStartEndCursor");

var _addStartEndCursor2 = _interopRequireDefault(_addStartEndCursor);

var _omit = require("../omit");

var _omit2 = _interopRequireDefault(_omit);

var _makeProcField = require("./makeProcField");

var _makeProcField2 = _interopRequireDefault(_makeProcField);

var _parseIdentifier = require("../parseIdentifier");

var _parseIdentifier2 = _interopRequireDefault(_parseIdentifier);

var _viaTemporaryTable = require("./viaTemporaryTable");

var _viaTemporaryTable2 = _interopRequireDefault(_viaTemporaryTable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultPgColumnFilter = (_attr, _build, _context) => true;
function preventEmptyResult(obj) {
  return Object.keys(obj).reduce((memo, key) => {
    const fn = obj[key];
    memo[key] = function (...args) {
      const result = fn.apply(this, args);
      if (typeof result !== "string" || result.length === 0) {
        const stringifiedArgs = require("util").inspect(args);
        throw new Error(`Inflector for '${key}' returned '${String(result)}'; expected non-empty string\n` + `See: https://github.com/graphile/graphile-build/blob/master/packages/graphile-build-pg/src/plugins/PgBasicsPlugin.js\n` + `Arguments passed to ${key}:\n${stringifiedArgs}`);
      }
      return result;
    };
    return memo;
  }, {});
}

function omitWithRBACChecks(entity, permission) {
  const ORDINARY_TABLE = "r";
  const VIEW = "v";
  const MATERIALIZED_VIEW = "m";
  const isTableLike = entity => entity && entity.kind === "class" && (entity.classKind === ORDINARY_TABLE || entity.classKind === VIEW || entity.classKind === MATERIALIZED_VIEW);
  if (entity.kind === "procedure") {
    if (permission === _omit.EXECUTE && !entity.aclExecutable) {
      return true;
    }
  } else if (entity.kind === "class" && isTableLike(entity)) {
    const tableEntity = entity;
    if ((permission === _omit.READ || permission === _omit.ALL || permission === _omit.MANY) && !tableEntity.aclSelectable && !tableEntity.attributes.some(attr => attr.aclSelectable)) {
      return true;
    } else if (permission === _omit.CREATE && !tableEntity.aclInsertable && !tableEntity.attributes.some(attr => attr.aclInsertable)) {
      return true;
    } else if (permission === _omit.UPDATE && !tableEntity.aclUpdatable && !tableEntity.attributes.some(attr => attr.aclUpdatable)) {
      return true;
    } else if (permission === _omit.DELETE && !tableEntity.aclDeletable) {
      return true;
    }
  } else if (entity.kind === "attribute" && isTableLike(entity.class)) {
    const attributeEntity = entity;

    const klass = attributeEntity.class;
    // Have we got *any* permissions on the table?
    if (klass.aclSelectable || klass.attributes.some(attr => attr.aclSelectable)) {
      // Yes; this is a regular table; omit if RBAC permissions tell us to.
      if ((permission === _omit.READ || permission === _omit.FILTER || permission === _omit.ORDER) && !attributeEntity.aclSelectable) {
        return true;
      } else if (permission === _omit.CREATE && !attributeEntity.aclInsertable) {
        return true;
      } else if (permission === _omit.UPDATE && !attributeEntity.aclUpdatable) {
        return true;
      }
    } else {
      // No permissions on the table at all, so normal connections will skip
      // over it. Thus we must be being exposed via a security definer function
      // or similar, so we should expose all fields except those that are
      // explicitly @omit-ed.
    }
  }
  return (0, _omit2.default)(entity, permission);
}

exports.default = function PgBasicsPlugin(builder, {
  pgStrictFunctions = false,
  pgColumnFilter = defaultPgColumnFilter,
  pgIgnoreRBAC = false
}) {
  const pgOmit = pgIgnoreRBAC ? _omit2.default : omitWithRBACChecks;
  builder.hook("build", build => {
    return build.extend(build, {
      graphileBuildPgVersion: _package.version,
      pgSql: _pgSql2.default,
      pgStrictFunctions,
      pgColumnFilter,
      pgQueryFromResolveData: _queryFromResolveData2.default,
      pgAddStartEndCursor: _addStartEndCursor2.default,
      pgOmit,
      pgMakeProcField: _makeProcField2.default,
      pgParseIdentifier: _parseIdentifier2.default,
      pgViaTemporaryTable: _viaTemporaryTable2.default
    });
  });

  builder.hook("inflection", (inflection, build) => {
    return build.extend(inflection, preventEmptyResult({
      // These helpers are passed GraphQL type names as strings
      conditionType(typeName) {
        return this.upperCamelCase(`${typeName}-condition`);
      },
      inputType(typeName) {
        return this.upperCamelCase(`${typeName}-input`);
      },
      rangeBoundType(typeName) {
        return this.upperCamelCase(`${typeName}-range-bound`);
      },
      rangeType(typeName) {
        return this.upperCamelCase(`${typeName}-range`);
      },
      patchType(typeName) {
        return this.upperCamelCase(`${typeName}-patch`);
      },
      baseInputType(typeName) {
        return this.upperCamelCase(`${typeName}-base-input`);
      },
      patchField(itemName) {
        return this.camelCase(`${itemName}-patch`);
      },
      orderByType(typeName) {
        return this.upperCamelCase(`${this.pluralize(typeName)}-order-by`);
      },
      edge(typeName) {
        return this.upperCamelCase(`${this.pluralize(typeName)}-edge`);
      },
      connection(typeName) {
        return this.upperCamelCase(`${this.pluralize(typeName)}-connection`);
      },

      // These helpers handle overrides via smart comments. They should only
      // be used in other inflectors, hence the underscore prefix.
      //
      // IMPORTANT: do NOT do case transforms here, because detail can be
      // lost, e.g.
      // `constantCase(camelCase('foo_1')) !== constantCase('foo_1')`
      _functionName(proc) {
        return proc.tags.name || proc.name;
      },
      _typeName(type) {
        // 'type' introspection result
        return type.tags.name || type.name;
      },
      _tableName(table) {
        return table.tags.name || table.type.tags.name || table.name;
      },
      _singularizedTableName(table) {
        return this.singularize(this._tableName(table)).replace(/.(?:(?:[_-]i|I)nput|(?:[_-]p|P)atch)$/, "$&_record");
      },
      _columnName(attr, _options) {
        return attr.tags.name || attr.name;
      },

      // From here down, functions are passed database introspection results
      enumType(type) {
        return this.upperCamelCase(this._typeName(type));
      },
      argument(name, index) {
        return this.camelCase(name || `arg${index}`);
      },
      orderByColumnEnum(attr, ascending) {
        const columnName = this._columnName(attr, {
          skipRowId: true // Because we messed up ðŸ˜”
        });
        return this.constantCase(`${columnName}_${ascending ? "asc" : "desc"}`);
      },
      domainType(type) {
        return this.upperCamelCase(this._typeName(type));
      },
      enumName(inValue) {
        let value = inValue;

        if (value === "") {
          return "_EMPTY_";
        }

        // Some enums use asterisks to signify wildcards - this might be for
        // the whole item, or prefixes/suffixes, or even in the middle.  This
        // is provided on a best efforts basis, if it doesn't suit your
        // purposes then please pass a custom inflector as mentioned below.
        value = value.replace(/\*/g, "_ASTERISK_").replace(/^(_?)_+ASTERISK/, "$1ASTERISK").replace(/ASTERISK_(_?)_*$/, "ASTERISK$1");

        // This is a best efforts replacement for common symbols that you
        // might find in enums. Generally we only support enums that are
        // alphanumeric, if these replacements don't work for you, you should
        // pass a custom inflector that replaces this `enumName` method
        // with one of your own chosing.
        value = {
          // SQL comparison operators
          ">": "GREATER_THAN",
          ">=": "GREATER_THAN_OR_EQUAL",
          "=": "EQUAL",
          "!=": "NOT_EQUAL",
          "<>": "DIFFERENT",
          "<=": "LESS_THAN_OR_EQUAL",
          "<": "LESS_THAN",

          // PostgreSQL LIKE shortcuts
          "~~": "LIKE",
          "~~*": "ILIKE",
          "!~~": "NOT_LIKE",
          "!~~*": "NOT_ILIKE",

          // '~' doesn't necessarily represent regexps, but the three
          // operators following it likely do, so we'll use the word TILDE
          // in all for consistency.
          "~": "TILDE",
          "~*": "TILDE_ASTERISK",
          "!~": "NOT_TILDE",
          "!~*": "NOT_TILDE_ASTERISK",

          // A number of other symbols where we're not sure of their
          // meaning.  We give them common generic names so that they're
          // suitable for multiple purposes, e.g. favouring 'PLUS' over
          // 'ADDITION' and 'DOT' over 'FULL_STOP'
          "%": "PERCENT",
          "+": "PLUS",
          "-": "MINUS",
          "/": "SLASH",
          "\\": "BACKSLASH",
          _: "UNDERSCORE",
          "#": "POUND",
          "Â£": "STERLING",
          $: "DOLLAR",
          "&": "AMPERSAND",
          "@": "AT",
          "'": "APOSTROPHE",
          '"': "QUOTE",
          "`": "BACKTICK",
          ":": "COLON",
          ";": "SEMICOLON",
          "!": "EXCLAMATION_POINT",
          "?": "QUESTION_MARK",
          ",": "COMMA",
          ".": "DOT",
          "^": "CARET",
          "|": "BAR",
          "[": "OPEN_BRACKET",
          "]": "CLOSE_BRACKET",
          "(": "OPEN_PARENTHESIS",
          ")": "CLOSE_PARENTHESIS",
          "{": "OPEN_BRACE",
          "}": "CLOSE_BRACE"
        }[value] || value;
        return value;
      },

      tableNode(table) {
        return this.camelCase(this._singularizedTableName(table));
      },
      tableFieldName(table) {
        return this.camelCase(this._singularizedTableName(table));
      },
      allRows(table) {
        return this.camelCase(`all-${this.pluralize(this._singularizedTableName(table))}`);
      },
      allRowsSimple(table) {
        return this.camelCase(`all-${this.pluralize(this._singularizedTableName(table))}-list`);
      },
      functionMutationName(proc) {
        return this.camelCase(this._functionName(proc));
      },
      functionQueryName(proc) {
        return this.camelCase(this._functionName(proc));
      },
      functionQueryNameList(proc) {
        return this.camelCase(`${this._functionName(proc)}-list`);
      },
      functionPayloadType(proc) {
        return this.upperCamelCase(`${this._functionName(proc)}-payload`);
      },
      functionInputType(proc) {
        return this.upperCamelCase(`${this._functionName(proc)}-input`);
      },
      tableType(table) {
        return this.upperCamelCase(this._singularizedTableName(table));
      },
      column(attr) {
        return this.camelCase(this._columnName(attr));
      },
      computedColumn(pseudoColumnName, proc, _table) {
        return proc.tags.fieldName || this.camelCase(pseudoColumnName);
      },
      computedColumnList(pseudoColumnName, proc, _table) {
        return proc.tags.fieldName ? proc.tags.fieldName + "List" : this.camelCase(`${pseudoColumnName}-list`);
      },
      singleRelationByKeys(detailedKeys, table, _foreignTable, constraint) {
        if (constraint.tags.fieldName) {
          return constraint.tags.fieldName;
        }
        return this.camelCase(`${this._singularizedTableName(table)}-by-${detailedKeys.map(key => this.column(key)).join("-and-")}`);
      },
      manyRelationByKeys(detailedKeys, table, _foreignTable, constraint) {
        if (constraint.tags.foreignFieldName) {
          return constraint.tags.foreignFieldName;
        }
        return this.camelCase(`${this.pluralize(this._singularizedTableName(table))}-by-${detailedKeys.map(key => this.column(key)).join("-and-")}`);
      },
      manyRelationByKeysSimple(detailedKeys, table, _foreignTable, constraint) {
        if (constraint.tags.foreignFieldName) {
          return constraint.tags.foreignFieldName;
        }
        return this.camelCase(`${this.pluralize(this._singularizedTableName(table))}-by-${detailedKeys.map(key => this.column(key)).join("-and-")}-list`);
      },
      rowByUniqueKeys(detailedKeys, table, constraint) {
        if (constraint.tags.fieldName) {
          return constraint.tags.fieldName;
        }
        return this.camelCase(`${this._singularizedTableName(table)}-by-${detailedKeys.map(key => this.column(key)).join("-and-")}`);
      },
      updateByKeys(detailedKeys, table, constraint) {
        if (constraint.tags.updateFieldName) {
          return constraint.tags.updateFieldName;
        }
        return this.camelCase(`update-${this._singularizedTableName(table)}-by-${detailedKeys.map(key => this.column(key)).join("-and-")}`);
      },
      deleteByKeys(detailedKeys, table, constraint) {
        if (constraint.tags.deleteFieldName) {
          return constraint.tags.deleteFieldName;
        }
        return this.camelCase(`delete-${this._singularizedTableName(table)}-by-${detailedKeys.map(key => this.column(key)).join("-and-")}`);
      },
      updateByKeysInputType(detailedKeys, table, constraint) {
        if (constraint.tags.updateFieldName) {
          return this.upperCamelCase(`${constraint.tags.updateFieldName}-input`);
        }
        return this.upperCamelCase(`update-${this._singularizedTableName(table)}-by-${detailedKeys.map(key => this.column(key)).join("-and-")}-input`);
      },
      deleteByKeysInputType(detailedKeys, table, constraint) {
        if (constraint.tags.deleteFieldName) {
          return this.upperCamelCase(`${constraint.tags.deleteFieldName}-input`);
        }
        return this.upperCamelCase(`delete-${this._singularizedTableName(table)}-by-${detailedKeys.map(key => this.column(key)).join("-and-")}-input`);
      },
      updateNode(table) {
        return this.camelCase(`update-${this._singularizedTableName(table)}`);
      },
      deleteNode(table) {
        return this.camelCase(`delete-${this._singularizedTableName(table)}`);
      },
      updateNodeInputType(table) {
        return this.upperCamelCase(`update-${this._singularizedTableName(table)}-input`);
      },
      deleteNodeInputType(table) {
        return this.upperCamelCase(`delete-${this._singularizedTableName(table)}-input`);
      },
      edgeField(table) {
        return this.camelCase(`${this._singularizedTableName(table)}-edge`);
      },
      scalarFunctionConnection(proc) {
        return this.upperCamelCase(`${this._functionName(proc)}-connection`);
      },
      scalarFunctionEdge(proc) {
        return this.upperCamelCase(`${this.singularize(this._functionName(proc))}-edge`);
      },
      createField(table) {
        return this.camelCase(`create-${this._singularizedTableName(table)}`);
      },
      createInputType(table) {
        return this.upperCamelCase(`create-${this._singularizedTableName(table)}-input`);
      },
      createPayloadType(table) {
        return this.upperCamelCase(`create-${this._singularizedTableName(table)}-payload`);
      },
      updatePayloadType(table) {
        return this.upperCamelCase(`update-${this._singularizedTableName(table)}-payload`);
      },
      deletePayloadType(table) {
        return this.upperCamelCase(`delete-${this._singularizedTableName(table)}-payload`);
      }
    }));
  });
};
//# sourceMappingURL=PgBasicsPlugin.js.map