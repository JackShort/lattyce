"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pg_1 = require("pg");
const pg_connection_string_1 = require("pg-connection-string");
const events_1 = require("events");
const postgraphile_core_1 = require("postgraphile-core");
const createPostGraphileHttpRequestHandler_1 = require("./http/createPostGraphileHttpRequestHandler");
const exportPostGraphileSchema_1 = require("./schema/exportPostGraphileSchema");
const pluginHook_1 = require("./pluginHook");
/**
 * Creates a PostGraphile Http request handler by first introspecting the
 * database to get a GraphQL schema, and then using that to create the Http
 * request handler.
 */
function getPostgraphileSchemaBuilder(pgPool, schema, incomingOptions) {
    const pluginHook = pluginHook_1.pluginHookFromOptions(incomingOptions);
    const options = pluginHook('postgraphile:options', incomingOptions, {
        pgPool,
        schema,
    });
    // Check for a jwtSecret without a jwtPgTypeIdentifier
    // a secret without a token identifier prevents JWT creation
    if (options.jwtSecret && !options.jwtPgTypeIdentifier) {
        // tslint:disable-next-line no-console
        console.warn('WARNING: jwtSecret provided, however jwtPgTypeIdentifier (token identifier) not provided.');
    }
    if (options.handleErrors && (options.extendedErrors || options.showErrorStack)) {
        throw new Error(`You cannot combine 'handleErrors' with the other error options`);
    }
    // Creates the Postgres schemas array.
    const pgSchemas = Array.isArray(schema) ? schema : [schema];
    const _emitter = new events_1.EventEmitter();
    // Creates a promise which will resolve to a GraphQL schema. Connects a
    // client from our pool to introspect the database.
    //
    // This is not a constant because when we are in watch mode, we want to swap
    // out the `gqlSchema`.
    let gqlSchema;
    const gqlSchemaPromise = createGqlSchema();
    return {
        _emitter,
        getGraphQLSchema: () => Promise.resolve(gqlSchema || gqlSchemaPromise),
    };
    async function createGqlSchema() {
        try {
            if (options.watchPg) {
                await postgraphile_core_1.watchPostGraphileSchema(pgPool, pgSchemas, options, (newSchema) => {
                    gqlSchema = newSchema;
                    _emitter.emit('schemas:changed');
                    exportGqlSchema(gqlSchema);
                });
                if (!gqlSchema) {
                    throw new Error("Consistency error: watchPostGraphileSchema promises to call the callback before the promise resolves; but this hasn't happened");
                }
            }
            else {
                gqlSchema = await postgraphile_core_1.createPostGraphileSchema(pgPool, pgSchemas, options);
                exportGqlSchema(gqlSchema);
            }
            return gqlSchema;
        }
        catch (error) {
            // If we fail to build our schema, log the error and exit the process.
            return handleFatalError(error);
        }
    }
    async function exportGqlSchema(newGqlSchema) {
        try {
            await exportPostGraphileSchema_1.default(newGqlSchema, options);
        }
        catch (error) {
            // If we fail to export our schema, log the error and exit the process.
            handleFatalError(error);
        }
    }
}
exports.getPostgraphileSchemaBuilder = getPostgraphileSchemaBuilder;
function postgraphile(poolOrConfig, schemaOrOptions, maybeOptions) {
    let schema;
    let options;
    // If the second argument is undefined, use defaults for both `schema` and
    // `options`.
    if (typeof schemaOrOptions === 'undefined') {
        schema = 'public';
        options = {};
    }
    // If the second argument is a string or array, it is the schemas so set the
    // `schema` value and try to use the third argument (or a default) for
    // `options`.
    else if (typeof schemaOrOptions === 'string' || Array.isArray(schemaOrOptions)) {
        schema = schemaOrOptions;
        options = maybeOptions || {};
    }
    // Otherwise the second argument is the options so set `schema` to the
    // default and `options` to the second argument.
    else {
        schema = 'public';
        options = schemaOrOptions;
    }
    // Do some things with `poolOrConfig` so that in the end, we actually get a
    // Postgres pool.
    const pgPool = 
    // If it is already a `Pool`, just use it.
    poolOrConfig instanceof pg_1.Pool || quacksLikePgPool(poolOrConfig)
        ? poolOrConfig
        : new pg_1.Pool(typeof poolOrConfig === 'string'
            ? // Otherwise if it is a string, let us parse it to get a config to
                // create a `Pool`.
                pg_connection_string_1.parse(poolOrConfig)
            : // Finally, it must just be a config itself. If it is undefined, we
                // will just use an empty config and let the defaults take over.
                poolOrConfig || {});
    const { getGraphQLSchema, _emitter } = getPostgraphileSchemaBuilder(pgPool, schema, options);
    return createPostGraphileHttpRequestHandler_1.default(Object.assign({}, options, { getGqlSchema: getGraphQLSchema, pgPool,
        _emitter }));
}
exports.default = postgraphile;
function handleFatalError(error) {
    process.stderr.write(`${error.stack}\n`); // console.error fails under the tests
    process.exit(1);
    // `process.exit` will mean all code below it will never get called.
    // However, we need to return a value with type `never` here for
    // TypeScript.
    return null;
}
function constructorName(obj) {
    return ((obj &&
        typeof obj.constructor === 'function' &&
        obj.constructor.name &&
        String(obj.constructor.name)) ||
        null);
}
// tslint:disable-next-line no-any
function quacksLikePgPool(pgConfig) {
    // A diagnosis of exclusion
    if (!pgConfig || typeof pgConfig !== 'object')
        return false;
    if (constructorName(pgConfig) !== 'Pool' && constructorName(pgConfig) !== 'BoundPool')
        return false;
    if (!pgConfig['Client'])
        return false;
    if (!pgConfig['options'])
        return false;
    if (typeof pgConfig['connect'] !== 'function')
        return false;
    if (typeof pgConfig['end'] !== 'function')
        return false;
    if (typeof pgConfig['query'] !== 'function')
        return false;
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9zdGdyYXBoaWxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Bvc3RncmFwaGlsZS9wb3N0Z3JhcGhpbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwyQkFBc0M7QUFDdEMsK0RBQXdFO0FBRXhFLG1DQUFzQztBQUN0Qyx5REFBc0Y7QUFDdEYsc0dBQStGO0FBQy9GLGdGQUF5RTtBQUN6RSw2Q0FBcUQ7QUFRckQ7Ozs7R0FJRztBQUNILHNDQUNFLE1BQVksRUFDWixNQUE4QixFQUM5QixlQUFvQztJQUVwQyxNQUFNLFVBQVUsR0FBRyxrQ0FBcUIsQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUMxRCxNQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsc0JBQXNCLEVBQUUsZUFBZSxFQUFFO1FBQ2xFLE1BQU07UUFDTixNQUFNO0tBQ1AsQ0FBQyxDQUFDO0lBQ0gsc0RBQXNEO0lBQ3RELDREQUE0RDtJQUM1RCxJQUFJLE9BQU8sQ0FBQyxTQUFTLElBQUksQ0FBQyxPQUFPLENBQUMsbUJBQW1CLEVBQUU7UUFDckQsc0NBQXNDO1FBQ3RDLE9BQU8sQ0FBQyxJQUFJLENBQ1YsMkZBQTJGLENBQzVGLENBQUM7S0FDSDtJQUVELElBQUksT0FBTyxDQUFDLFlBQVksSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLElBQUksT0FBTyxDQUFDLGNBQWMsQ0FBQyxFQUFFO1FBQzlFLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0VBQWdFLENBQUMsQ0FBQztLQUNuRjtJQUVELHNDQUFzQztJQUN0QyxNQUFNLFNBQVMsR0FBa0IsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRTNFLE1BQU0sUUFBUSxHQUFHLElBQUkscUJBQVksRUFBRSxDQUFDO0lBRXBDLHVFQUF1RTtJQUN2RSxtREFBbUQ7SUFDbkQsRUFBRTtJQUNGLDRFQUE0RTtJQUM1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