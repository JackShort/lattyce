{"version":3,"sources":["../src/index.js"],"names":["getAliasFromResolveInfo","parseResolveInfo","simplifyParsedResolveInfoFragmentWithType","debug","getArgVal","resolveInfo","argument","kind","variableValues","name","value","skipField","directives","skip","forEach","directive","directiveName","Array","isArray","arguments","ifArgumentAst","find","arg","argumentValueAst","asts","fieldNodes","fieldASTs","i","l","length","val","alias","Error","options","parentType","keepRoot","deep","tree","fieldTreeFromAST","undefined","typeKey","firstKey","fieldKey","getFieldFromAST","ast","fieldNode","fieldName","GraphQLUnionType","type","getFields","iNum","inASTs","initTree","depth","instance","fragments","outerDepth","reduce","selectionVal","idx","isReserved","substr","field","fieldGqlType","args","newTreeRoot","fieldsByTypeName","selectionSet","newParentType","selections","fragment","fragmentType","typeCondition","getType","obj","key","schema","typeName","parsedResolveInfoFragment","Type","fields","StrippedType","Object","assign","GraphQLObjectType","ObjectType","Interface","getInterfaces","parse","simplify","getAlias"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\n\nimport assert from \"assert\";\nimport { getArgumentValues } from \"graphql/execution/values\";\nimport {\n  getNamedType,\n  isCompositeType,\n  GraphQLObjectType,\n  GraphQLUnionType,\n} from \"graphql\";\nimport debugFactory from \"debug\";\n\nimport type {\n  GraphQLResolveInfo,\n  GraphQLField,\n  GraphQLCompositeType,\n  GraphQLInterfaceType,\n  GraphQLType,\n} from \"graphql/type/definition\";\n\nimport type {\n  ASTNode,\n  FieldNode,\n  SelectionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n} from \"graphql/language/ast\";\n\nexport type FieldsByTypeName = {\n  [string]: {\n    [string]: ResolveTree,\n  },\n};\n\nexport type ResolveTree = {\n  name: string,\n  alias: string,\n  args: {\n    [string]: mixed,\n  },\n  fieldsByTypeName: FieldsByTypeName,\n};\n\nconst debug = debugFactory(\"graphql-parse-resolve-info\");\n\nfunction getArgVal(resolveInfo, argument) {\n  if (argument.kind === \"Variable\") {\n    return resolveInfo.variableValues[argument.name.value];\n  } else if (argument.kind === \"BooleanValue\") {\n    return argument.value;\n  }\n}\n\nfunction skipField(resolveInfo, { directives = [] }) {\n  let skip = false;\n  directives.forEach(directive => {\n    const directiveName = directive.name.value;\n    if (Array.isArray(directive.arguments)) {\n      const ifArgumentAst = directive.arguments.find(\n        arg => arg.name && arg.name.value === \"if\"\n      );\n      if (ifArgumentAst) {\n        const argumentValueAst = ifArgumentAst.value;\n        if (directiveName === \"skip\") {\n          skip = skip || getArgVal(resolveInfo, argumentValueAst);\n        } else if (directiveName === \"include\") {\n          skip = skip || !getArgVal(resolveInfo, argumentValueAst);\n        }\n      }\n    }\n  });\n  return skip;\n}\n\n// Originally based on https://github.com/tjmehta/graphql-parse-fields\n\nexport function getAliasFromResolveInfo(\n  resolveInfo: GraphQLResolveInfo\n): string {\n  const asts = resolveInfo.fieldNodes || resolveInfo.fieldASTs;\n  for (let i = 0, l = asts.length; i < l; i++) {\n    const val = asts[i];\n    if (val.kind === \"Field\") {\n      const alias = val.alias ? val.alias.value : val.name && val.name.value;\n      if (alias) {\n        return alias;\n      }\n    }\n  }\n  throw new Error(\"Could not determine alias?!\");\n}\n\nexport function parseResolveInfo(\n  resolveInfo: GraphQLResolveInfo,\n  options: { keepRoot?: boolean, deep?: boolean } = {}\n): ResolveTree | FieldsByTypeName | null | void {\n  const fieldNodes: $ReadOnlyArray<FieldNode> =\n    resolveInfo.fieldNodes || resolveInfo.fieldASTs;\n\n  const { parentType } = resolveInfo;\n  if (!fieldNodes) {\n    throw new Error(\"No fieldNodes provided!\");\n  }\n  if (options.keepRoot == null) {\n    options.keepRoot = false;\n  }\n  if (options.deep == null) {\n    options.deep = true;\n  }\n  let tree = fieldTreeFromAST(\n    fieldNodes,\n    resolveInfo,\n    undefined,\n    options,\n    parentType\n  );\n  if (!options.keepRoot) {\n    const typeKey = firstKey(tree);\n    if (!typeKey) {\n      return null;\n    }\n    tree = tree[typeKey];\n    const fieldKey = firstKey(tree);\n    if (!fieldKey) {\n      return null;\n    }\n    tree = tree[fieldKey];\n  }\n  return tree;\n}\n\nfunction getFieldFromAST(\n  ast: ASTNode,\n  parentType: GraphQLCompositeType\n): ?GraphQLField<*, *> {\n  if (ast.kind === \"Field\") {\n    const fieldNode: FieldNode = ast;\n    const fieldName = fieldNode.name.value;\n    if (!(parentType instanceof GraphQLUnionType)) {\n      const type: GraphQLObjectType | GraphQLInterfaceType = parentType;\n      return type.getFields()[fieldName];\n    } else {\n      // XXX: TODO: Handle GraphQLUnionType\n    }\n  }\n  return;\n}\n\nlet iNum = 1;\nfunction fieldTreeFromAST<T: SelectionNode>(\n  inASTs: $ReadOnlyArray<T> | T,\n  resolveInfo: GraphQLResolveInfo,\n  initTree: FieldsByTypeName = {},\n  options = {},\n  parentType: GraphQLCompositeType,\n  depth = \"\"\n): FieldsByTypeName {\n  const instance = iNum++;\n  debug(\n    \"%s[%d] Entering fieldTreeFromAST with parent type '%s'\",\n    depth,\n    instance,\n    parentType\n  );\n  let { variableValues } = resolveInfo;\n  const fragments = resolveInfo.fragments || {};\n  const asts: $ReadOnlyArray<T> = Array.isArray(inASTs) ? inASTs : [inASTs];\n  initTree[parentType.name] = initTree[parentType.name] || {};\n  const outerDepth = depth;\n  return asts.reduce(function(tree, selectionVal: SelectionNode, idx) {\n    const depth = `${outerDepth}  `;\n    debug(\n      \"%s[%d] Processing AST %d of %d; kind = %s\",\n      depth,\n      instance,\n      idx + 1,\n      asts.length,\n      selectionVal.kind\n    );\n    if (skipField(resolveInfo, selectionVal)) {\n      debug(\"%s[%d] IGNORING due to directive\", depth, instance);\n    } else if (selectionVal.kind === \"Field\") {\n      const val: FieldNode = selectionVal;\n      const name = val.name && val.name.value;\n      const isReserved = name && name !== \"__id\" && name.substr(0, 2) === \"__\";\n      if (isReserved) {\n        debug(\n          \"%s[%d] IGNORING because field '%s' is reserved\",\n          depth,\n          instance,\n          name\n        );\n      } else {\n        const alias: string =\n          val.alias && val.alias.value ? val.alias.value : val.name.value;\n        debug(\"%s[%d] Field '%s' (alias = '%s')\", depth, instance, name, alias);\n        const field = getFieldFromAST(val, parentType);\n        if (!field) {\n          return tree;\n        }\n        const fieldGqlType = getNamedType(field.type);\n        if (!fieldGqlType) {\n          return tree;\n        }\n        const args = getArgumentValues(field, val, variableValues) || {};\n        if (parentType.name && !tree[parentType.name][alias]) {\n          const newTreeRoot: ResolveTree = {\n            name,\n            alias,\n            args,\n            fieldsByTypeName: isCompositeType(fieldGqlType)\n              ? {\n                  [fieldGqlType.name]: {},\n                }\n              : {},\n          };\n          tree[parentType.name][alias] = newTreeRoot;\n        }\n        const selectionSet = val.selectionSet;\n        if (\n          selectionSet != null &&\n          options.deep &&\n          isCompositeType(fieldGqlType)\n        ) {\n          const newParentType: GraphQLCompositeType = fieldGqlType;\n          debug(\"%s[%d] Recursing into subfields\", depth, instance);\n          fieldTreeFromAST(\n            selectionSet.selections,\n            resolveInfo,\n            tree[parentType.name][alias].fieldsByTypeName,\n            options,\n            newParentType,\n            `${depth}  `\n          );\n        } else {\n          // No fields to add\n          debug(\"%s[%d] Exiting (no fields to add)\", depth, instance);\n        }\n      }\n    } else if (selectionVal.kind === \"FragmentSpread\" && options.deep) {\n      const val: FragmentSpreadNode = selectionVal;\n      const name = val.name && val.name.value;\n      debug(\"%s[%d] Fragment spread '%s'\", depth, instance, name);\n      const fragment = fragments[name];\n      assert(fragment, 'unknown fragment \"' + name + '\"');\n      let fragmentType = parentType;\n      if (fragment.typeCondition) {\n        fragmentType = getType(resolveInfo, fragment.typeCondition);\n      }\n      if (fragmentType && isCompositeType(fragmentType)) {\n        const newParentType: GraphQLCompositeType = fragmentType;\n        fieldTreeFromAST(\n          fragment.selectionSet.selections,\n          resolveInfo,\n          tree,\n          options,\n          newParentType,\n          `${depth}  `\n        );\n      }\n    } else if (selectionVal.kind === \"InlineFragment\" && options.deep) {\n      const val: InlineFragmentNode = selectionVal;\n      const fragment = val;\n      let fragmentType = parentType;\n      if (fragment.typeCondition) {\n        fragmentType = getType(resolveInfo, fragment.typeCondition);\n      }\n      debug(\n        \"%s[%d] Inline fragment (parent = '%s', type = '%s')\",\n        depth,\n        instance,\n        parentType,\n        fragmentType\n      );\n      if (fragmentType && isCompositeType(fragmentType)) {\n        const newParentType: GraphQLCompositeType = fragmentType;\n        fieldTreeFromAST(\n          fragment.selectionSet.selections,\n          resolveInfo,\n          tree,\n          options,\n          newParentType,\n          `${depth}  `\n        );\n      }\n    } else {\n      debug(\n        \"%s[%d] IGNORING because kind '%s' not understood\",\n        depth,\n        instance,\n        selectionVal.kind\n      );\n    }\n    // Ref: https://github.com/graphile/postgraphile/pull/342/files#diff-d6702ec9fed755c88b9d70b430fda4d8R148\n    return tree;\n  }, initTree);\n}\n\nfunction firstKey(obj) {\n  for (const key in obj) {\n    return key;\n  }\n}\n\nfunction getType(resolveInfo, typeCondition) {\n  const { schema } = resolveInfo;\n  const { kind, name } = typeCondition;\n  if (kind === \"NamedType\") {\n    const typeName = name.value;\n    return schema.getType(typeName);\n  }\n}\n\nexport function simplifyParsedResolveInfoFragmentWithType(\n  parsedResolveInfoFragment: ResolveTree,\n  Type: GraphQLType\n) {\n  const { fieldsByTypeName } = parsedResolveInfoFragment;\n  const fields = {};\n  const StrippedType = getNamedType(Type);\n  if (isCompositeType(StrippedType)) {\n    Object.assign(fields, fieldsByTypeName[StrippedType.name]);\n    if (StrippedType instanceof GraphQLObjectType) {\n      const ObjectType: GraphQLObjectType = StrippedType;\n      // GraphQL ensures that the subfields cannot clash, so it's safe to simply overwrite them\n      for (const Interface of ObjectType.getInterfaces()) {\n        Object.assign(fields, fieldsByTypeName[Interface.name]);\n      }\n    }\n  }\n  return Object.assign({}, parsedResolveInfoFragment, {\n    fields,\n  });\n}\n\nexport const parse = parseResolveInfo;\nexport const simplify = simplifyParsedResolveInfoFragmentWithType;\nexport const getAlias = getAliasFromResolveInfo;\n"]}